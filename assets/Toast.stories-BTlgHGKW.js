import{j as m}from"./jsx-runtime-Nms4Y4qS.js";import{e as O}from"./index-B39sCSI7.js";import"./index-BwDkhjyp.js";import"./_commonjsHelpers-BosuxZz1.js";import"./index-CNtdgd3B.js";import"./index-DhtFSFNI.js";import"./index-B8XB3FuZ.js";const{Channel:E}=__STORYBOOK_MODULE_CHANNELS__,{global:i}=__STORYBOOK_MODULE_GLOBAL__,{logger:s}=__STORYBOOK_MODULE_CLIENT_LOGGER__,{STORY_RENDERED:U,UPDATE_STORY_ARGS:f,RESET_STORY_ARGS:C,UPDATE_GLOBALS:$,FORCE_RE_RENDER:z}=__STORYBOOK_MODULE_CORE_EVENTS__;function S(){let e={setHandler:()=>{},send:()=>{}};return new E({transport:e})}var T=class{constructor(){this.getChannel=()=>{if(!this.channel){let e=S();return this.setChannel(e),e}return this.channel},this.getServerChannel=()=>{if(!this.serverChannel)throw new Error("Accessing non-existent serverChannel");return this.serverChannel},this.ready=()=>this.promise,this.hasChannel=()=>!!this.channel,this.hasServerChannel=()=>!!this.serverChannel,this.setChannel=e=>{this.channel=e,this.resolve()},this.setServerChannel=e=>{this.serverChannel=e},this.promise=new Promise(e=>{this.resolve=()=>e(this.getChannel())})}},h="__STORYBOOK_ADDONS_PREVIEW";function R(){return i[h]||(i[h]=new T),i[h]}var v=R(),A=(e,t)=>e.length===t.length&&e.every((r,o)=>r===t[o]),u=()=>new Error("Storybook preview hooks can only be called inside decorators and story functions.");function w(){return i.STORYBOOK_HOOKS_CONTEXT||null}function _(){let e=w();if(e==null)throw u();return e}function y(e,t,r){let o=_();if(o.currentPhase==="MOUNT"){r!=null&&!Array.isArray(r)&&s.warn(`${e} received a final argument that is not an array (instead, received ${r}). When specified, the final argument must be an array.`);let n={name:e,deps:r};return o.currentHooks.push(n),t(n),n}if(o.currentPhase==="UPDATE"){let n=o.getNextHook();if(n==null)throw new Error("Rendered more hooks than during the previous render.");return n.name!==e&&s.warn(`Storybook has detected a change in the order of Hooks${o.currentDecoratorName?` called by ${o.currentDecoratorName}`:""}. This will lead to bugs and errors if not fixed.`),r!=null&&n.deps==null&&s.warn(`${e} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`),r!=null&&n.deps!=null&&r.length!==n.deps.length&&s.warn(`The final argument passed to ${e} changed size between renders. The order and size of this array must remain constant.
Previous: ${n.deps}
Incoming: ${r}`),(r==null||n.deps==null||!A(r,n.deps))&&(t(n),n.deps=r),n}throw u()}function k(e,t,r){let{memoizedState:o}=y(e,n=>{n.memoizedState=t()},r);return o}function c(e,t){return k("useCallback",()=>e,t)}function b(){let{currentContext:e}=_();if(e==null)throw u();return e}function D(){let e=v.getChannel(),{id:t,args:r}=b(),o=c(l=>e.emit(f,{storyId:t,updatedArgs:l}),[e,t]),n=c(l=>e.emit(C,{storyId:t,argNames:l}),[e,t]);return[r,o,n]}const G={title:"Data Display/Toast",component:O,argTypes:{open:{control:"boolean"}},args:{title:"Agendamento Realizado",description:"Quarta-feira, 16 de abril às 15h",open:!0}},N=({open:e,...t})=>{const[,r]=D(),o=n=>{r({open:n})};return m.jsx(O,{...t,open:e,onOpenChange:o})},a=N.bind({});a.args={title:"Agendamento Realizado",description:"Quarta-feira, 16 de abril às 15h",open:!0};var d,g,p;a.parameters={...a.parameters,docs:{...(d=a.parameters)==null?void 0:d.docs,source:{originalSource:`({
  open,
  ...args
}) => {
  const [, updateArgs] = useArgs();
  const handleOpenChange = (isOpen: boolean) => {
    updateArgs({
      open: isOpen
    });
  };
  return <Toast {...args} open={open} onOpenChange={handleOpenChange} />;
}`,...(p=(g=a.parameters)==null?void 0:g.docs)==null?void 0:p.source}}};const M=["Primary"];export{a as Primary,M as __namedExportsOrder,G as default};
